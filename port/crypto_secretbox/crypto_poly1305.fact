// using 64-bit implementation (poly1305_donna64.h)
// #define poly1305_block_size 16
struct poly1305_state_internal_t {
    secret uint64[3] r;
    secret uint64[3] h;
    secret uint64[2] pad;
    public uint64 leftover;
    secret uint8[16] buffer; // poly1305_block_size
    secret uint8 final;
}

void _poly1305_blocks(
    mut struct poly1305_state_internal_t state,
    secret uint8[] m) {
  public uint64 mask44 = 0xfffffffffff;
  public uint64 mask42 = 0x3ffffffffff;

  secret uint64 hibit = (state.final != 0) ? 0 : (((uint64)1) << 40);

  secret uint64 r0 = state.r[0];
  secret uint64 r1 = state.r[1];
  secret uint64 r2 = state.r[2];

  secret mut uint64 h0 = state.h[0];
  secret mut uint64 h1 = state.h[1];
  secret mut uint64 h2 = state.h[2];

  secret uint64 s1 = r1 * (5 << 2);
  secret uint64 s2 = r2 * (5 << 2);

  public mut uint32 mloops = (len m) >> 4; // dividing by 16
  for (uint32 bindex = 0 to mloops) {
    secret uint64 t0 = _load64_le(arrview(m, bindex * 16, 8));
    secret uint64 t1 = _load64_le(arrview(m, bindex * 16 + 8, 8));

    /* h += m[i] */
    // this is clearly some sort of odd-bit add-with-carry
    h0 += ((t0) & mask44);
    h1 += (((t0 >> 44) | (t1 << 20)) & mask44);
    h2 += (((t1 >> 24)) & mask42) | hibit;

    /* h *= r */
    secret mut uint128 d0 = (((uint128)h0) * r0) + (((uint128)h1) * s2) + (((uint128)h2) * s1);
    secret mut uint128 d1 = (((uint128)h0) * r1) + (((uint128)h1) * r0) + (((uint128)h2) * s2);
    secret mut uint128 d2 = (((uint128)h0) * r2) + (((uint128)h1) * r1) + (((uint128)h2) * r0);

    /* (partial) h %= p */
    secret mut uint64 c = (uint64)(d0 >> 44);
    h0 = (uint64)(d0) & mask44;
    d1 += c;
    c = (uint64)(d1 >> 44);
    h1 = (uint64)(d1) & mask44;
    d2 += c;
    c = (uint64)(d2 >> 42);
    h2 = (uint64)(d2) & mask42;
    h0 += c * 5;
    c = (uint64)(h0 >> 44);
    h0 &= mask44;
    h1 += c;
  }

  state.h[0] = h0;
  state.h[1] = h1;
  state.h[2] = h2;
}

void _poly1305_init(
    mut struct poly1305_state_internal_t state,
    secret uint8[32] key) {
  /* r &= 0xffffffc0ffffffc0ffffffc0fffffff */
  secret uint64 t0 = _load64_le(arrview(key, 0, 8));
  secret uint64 t1 = _load64_le(arrview(key, 8, 8));

  /* wiped after finalization */
  state.r[0] = (t0) & 0xffc0fffffff;
  state.r[1] = ((t0 >> 44) | (t1 << 20)) & 0xfffffc0ffff;
  state.r[2] = ((t1 >> 24)) & 0x00ffffffc0f;

  /* h = 0 */
  state.h[0] = 0;
  state.h[1] = 0;
  state.h[2] = 0;

  /* save pad for later */
  state.pad[0] = _load64_le(arrview(key, 16, 8));
  state.pad[1] = _load64_le(arrview(key, 24, 8));

  state.leftover = 0;
  state.final = 0;
}

void _poly1305_update(
    mut struct poly1305_state_internal_t state,
    secret uint8[] m) {
  public mut uint64 mindex = 0;

  /* handle leftover */
  if (state.leftover != 0) {
    public mut uint64 want = 16 - state.leftover;
    if (want > len m) {
      want = len m;
    }

    for (uint64 i = 0 to want) {
      state.buffer[state.leftover + i] = m[i];
    }
    mindex += want;
    state.leftover += want;
    if (state.leftover < 16) {
      return;
    }
    _poly1305_blocks(ref state, state.buffer);
    state.leftover = 0;
  }

  /* process full blocks */
  if (len m - mindex >= 16) {
    public uint64 want = ((len m - mindex) & ~(16 - 1)); // XXX wat

    secret uint8[] mview = arrview(m, mindex, want);
    _poly1305_blocks(ref state, mview);
    mindex += want;
  }

  /* store leftover */
  if (mindex < len m) {
    public uint64 remaining = len m - mindex;
    for (uint64 i = 0 to remaining) {
      state.buffer[state.leftover + i] = m[mindex + i];
    }
    state.leftover += remaining;
  }
}

void _poly1305_finish(
    mut struct poly1305_state_internal_t state,
    secret mut uint8[16] mac) {
  /* process the remaining block */
  if (state.leftover != 0) {
    public uint64 start = state.leftover;
    state.buffer[start] = 1;
    for (uint64 i = start + 1 to 16) {
      state.buffer[i] = 0;
    }
    state.final = 1;
    _poly1305_blocks(ref state, state.buffer);
  }

  public uint64 mask44 = 0xfffffffffff;
  public uint64 mask42 = 0x3ffffffffff;

  /* fully carry h */
  secret mut uint64 h0 = state.h[0];
  secret mut uint64 h1 = state.h[1];
  secret mut uint64 h2 = state.h[2];

  secret mut uint64 c = h1 >> 44;
  h1 &= mask44;
  h2 += c;
  c = h2 >> 42;
  h2 &= mask42;
  h0 += c * 5;
  c = h0 >> 44;
  h0 &= mask44;
  h1 += c;
  c = h1 >> 44;
  h1 &= mask44;
  h2 += c;
  c = h2 >> 42;
  h2 &= mask42;
  h0 += c * 5;
  c = h0 >> 44;
  h0 &= mask44;
  h1 += c;

  /* compute h + -p */
  secret mut uint64 g0 = h0 + 5;
  c = g0 >> 44;
  g0 &= mask44;
  secret mut uint64 g1 = h1 + c;
  c = g1 >> 44;
  g1 &= mask44;
  secret mut uint64 g2 = h2 + c - ((uint64)1 << 42);

  /* select h if h < p, or h + -p if h >= p */
  c = (g2 >> ((8 * 8) - 1)) - 1;
  g0 &= c;
  g1 &= c;
  g2 &= c;
  c = ~c;
  h0 = (h0 & c) | g0;
  h1 = (h1 & c) | g1;
  h2 = (h2 & c) | g2;

  /* h = (h + pad) */
  secret uint64 t0 = state.pad[0];
  secret uint64 t1 = state.pad[1];

  h0 += t0 & mask44;
  c = h0 >> 44;
  h0 &= mask44;
  h1 += (((t0 >> 44) | (t1 << 20)) & mask44) + c;
  c = h1 >> 44;
  h1 &= mask44;
  h2 += (((t1 >> 24)) & mask42) + c;
  h2 &= mask42;

  /* mac = h % (2^128) */
  h0 = (h0 | (h1 << 44));
  h1 = ((h1 >> 20) | (h2 << 24));

  _store64_le(ref arrview(mac, 0, 8), h0);
  _store64_le(ref arrview(mac, 8, 8), h1);

  /* zero out the state */
  _fact_memzero64(ref state.r);
  _fact_memzero64(ref state.h);
  _fact_memzero64(ref state.pad);
  state.leftover = 0;
  _fact_memzero(ref state.buffer);
  state.final = 0;
}

public int32 _crypto_onetimeauth_poly1305( // crypto_onetimeauth_poly1305_donna from poly1305_donna.c
    secret mut uint8[16] out,
    secret uint8[] m,
    secret uint8[32] key) {
  mut struct poly1305_state_internal_t state; // XXX this needs to be better
  _fact_memzero64(ref state.r);
  _fact_memzero64(ref state.h);
  _fact_memzero64(ref state.pad);
  state.leftover = 0;
  _fact_memzero(ref state.buffer);
  state.final = 0;

  _poly1305_init(ref state, key);
  _poly1305_update(ref state, m);
  _poly1305_finish(ref state, ref out);
  return 0;
}

public bool _crypto_onetimeauth_poly1305_verify( // crypto_onetimeauth_poly1305_donna_verify from poly1305.c
    public uint8[16] h,
    public uint8[] in,
    secret uint8[32] k) {
  secret mut uint8[16] correct = noinit(16);
  _crypto_onetimeauth_poly1305(ref correct, in, k);
  return declassify(_crypto_verify_16(h, correct));
}
